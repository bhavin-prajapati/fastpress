'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var net = _interopDefault(require('net'));

const parseHTTPRequest = (data) => {
  let parsedReq = {};
  let req = data.split('\r\n\r\n');
  let header = req[0];
  let body = req[1];

  // Parse headers
  let headers = {};
  let headerArr = header.split('\r\n');
  let method = headerArr[0].split(' ')[0];
  let url = headerArr[0].split(' ')[1];
  let chunks = [];
  let arr = [];

  for (let i = 1; i < headerArr.length; i++) {
    chunks = headerArr[i].split(': ');
    arr = [chunks.shift(), chunks.join(': ')];
    headers[arr[0]] = arr[1];
  }

  parsedReq.method = method;
  parsedReq.url = url;
  parsedReq.headers = headers;
  parsedReq.body = body;
  return parsedReq;
};

var HTTPParser = {
  parseHTTPRequest
};

class Response {
  constructor(s) {
    this.socket = s;
  }

  status(s) {
    this.status = s;
  }

  send(body) {
    // this.socket.write(`HTTP/1.x ${this.status} OK
    //     Transfer-Encoding: chunked
    //     Date: Sat, 28 Nov 2009 04:36:25 GMT
    //     Server: Fastpress
    //     Connection: close
    //     X-Powered-By: W3 Total Cache/0.8
    //     Pragma: public
    //     Expires: Sat, 28 Nov 2009 05:36:25 GMT
    //     Etag: "pub1259380237;gz"
    //     Cache-Control: max-age=3600, public
    //     Content-Type: application/json; charset=UTF-8
    //     Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT
    //     X-Pingback: http://net.tutsplus.com/xmlrpc.php
    //     Content-Encoding: gzip
    //     Vary: Accept-Encoding, Cookie, User-Agent`);
    this.socket.write('meow\r\n');
    this.socket.pipe(this.socket);
  }
}

const DEFAULT_HOSTNAME = '127.0.0.1';
const DEFAULT_PORT = '8080';

class Fastpress {
  constructor(s) {
    this.sock = s;
    this.host = DEFAULT_HOSTNAME;
    this.port = DEFAULT_PORT;
    this.routes = {};
  }

  listen(port, callback) {
    const _port = port ? port : this.port;

    // Create a server instance, and chain the listen function to it
    // The function passed to net.createServer() becomes the event handler for the 'connection' event
    // The sock object the callback function receives UNIQUE for each connection
    const server = net.createServer((sock) => {
      let res = new Response(sock);

      // We have a connection - a socket object is assigned to the connection automatically
      // console.log('CONNECTED: ' + sock.remoteAddress +':'+ sock.remotePort);
      // Add a 'data' event handler to this instance of socket
      sock.on('data', (data) => {
        let req = HTTPParser.parseHTTPRequest(data.toString());
        let route = req.method + ' ' + req.url.split('?')[0];

        console.log(route);
        this.routes[route] ? this.routes[route](req, res) : null;
      });

      // Add a 'close' event handler to this instance of socket
      sock.on('close', (data) => {
        console.log('CLOSED: ' + sock.remoteAddress + ' ' + sock.remotePort);
      });
    });

    server.on('error', (err) => {
      throw err;
    });

    server.listen(_port, this.host, () => {
      console.log(`Server started listening to port ${_port}`);
    });
    callback();
  };

  get(path, cb) {
    this.routes[`GET ${path}`] = cb;
  };

  post(path, cb) {
    this.routes[`POST ${path}`] = cb;
  };
}

module.exports = Fastpress;
